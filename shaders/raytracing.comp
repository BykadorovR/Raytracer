#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;
//gl_GlobalInvocationID.x, gl_GlobalInvocationID.y
//ivec2 dim = imageSize(resultImage);

#define AA_SAMPLES 100
#define MAX_SPHERES 10
#define MAX_DEPTH 50

#define MATERIAL_DIFFUSE 0
#define MATERIAL_METAL 1

struct Material {
  int type;
  vec3 attenuation;
  //actual only for metal
  float fuzz;
};

struct Sphere {
  vec3 center;
  float radius;
  Material material;
};

Sphere spheres[MAX_SPHERES];
int spheresNumber;
uint seed;

struct Ray {
  vec3 origin;
  vec3 direction;
};

struct HitRecord {
  vec3 normal;
  vec3 point;
  float t;
  Material material;
};

//https://github.com/GPSnoopy/RayTracingInVulkan/blob/master/assets/shaders/Random.glsl
uint InitRandomSeed(uint val0, uint val1)
{
  uint v0 = val0, v1 = val1, s0 = 0;

  for (uint n = 0; n < 16; n++)
  {
    s0 += 0x9e3779b9;
    v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
    v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
  }

  return v0;
}

uint RandomInt(inout uint seed)
{
  // LCG values from Numerical Recipes
    return (seed = 1664525 * seed + 1013904223);
}

float RandomFloat(inout uint seed)
{
  //// Float version using bitmask from Numerical Recipes
  //const uint one = 0x3f800000;
  //const uint msk = 0x007fffff;
  //return uintBitsToFloat(one | (msk & (RandomInt(seed) >> 9))) - 1;

  // Faster version from NVIDIA examples; quality good enough for our use case.
  return (float(RandomInt(seed) & 0x00FFFFFF) / float(0x01000000));
}

vec3 RandomInUnitSphere(inout uint seed) {
  for (;;)
  {
    const vec3 p = 2 * vec3(RandomFloat(seed), RandomFloat(seed), RandomFloat(seed)) - 1;
    if (dot(p, p) < 1)
    {
      return p;
    }
  }
}

bool nearZero(vec3 v) {
  // Return true if the vector is close to zero in all dimensions.
  float s = 1e-8;
  return (abs(v.x) < s) && (abs(v.y) < s) && (abs(v.z) < s);
}

//glsl has own function reflect
vec3 reflectRay(vec3 v, vec3 n) {
  return v - 2 * dot(v, n) * n;
}

bool metalMaterial(HitRecord hitRecord, inout Ray ray, inout vec3 color) {
  vec3 direction = reflectRay(ray.direction, hitRecord.normal);
  ray = Ray(hitRecord.point, direction + hitRecord.material.fuzz * RandomInUnitSphere(seed));
  color *= hitRecord.material.attenuation;
  return (dot(direction, hitRecord.normal) > 0);
}

bool diffuseMaterial(HitRecord hitRecord, inout Ray ray, inout vec3 color) {
  vec3 direction = hitRecord.normal + RandomInUnitSphere(seed);
  //if direction == 0 we will have issues with such direction (nan, undefined behavior)
  if (nearZero(direction)) {
    direction = hitRecord.normal;
  }
  ray = Ray(hitRecord.point, normalize(direction));
  //half of color is absorbing and half reflecting
  color *= hitRecord.material.attenuation;
  return true;
}

//t2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r2=0
float hitSphere(Ray ray, Sphere sphere, float tMin, float tMax) {
  vec3 oc = ray.origin - sphere.center;
  float a = dot(ray.direction, ray.direction);
  float b = 2 * dot(ray.direction, oc);
  float c = dot(oc, oc) - sphere.radius * sphere.radius;
  float disc = b * b - 4 * a * c;
  if (disc < 0)
    return -1;
  float sqrtd = sqrt(disc);
  float root1 = (-b - sqrtd ) / (2.0*a);
  if (root1 >= tMin && root1 <= tMax)
    return root1;

  float root2 = (-b + sqrtd ) / (2.0*a);
  if (root2 >= tMin && root2 <= tMax)
    return root2;

  return -1;
}

bool hitWorld(Ray ray, float tMin, float tMax, inout HitRecord hitRecord) {
  bool hit = false;
  //check if ray hit object, pick the closest object and generate reflected ray
  for (int i = 0; i < spheresNumber; i++) {
    Sphere sphere = spheres[i];
    float t = hitSphere(ray, sphere, tMin, tMax);
    if (t > 0.0) {
      hitRecord.material = sphere.material;
      hitRecord.point = ray.origin + ray.direction * t;
      //normal = point on ray that intersect shpere - sphere center
      hitRecord.normal = (hitRecord.point - sphere.center) / sphere.radius;
      tMax = t;
      hit = true;
    }
  }

  return hit;
}

vec3 rayColor(Ray ray) {
  vec3 resultColor = vec3(1.0, 1.0, 1.0);
  int depth = MAX_DEPTH;
  while (depth > 0) {
    bool hit = false;
    HitRecord hitRecord;
    //check if ray hit object, pick the closest object and generate reflected ray
    if (hitWorld(ray, 0.001, 100000, hitRecord)) {
      bool success;
      if (hitRecord.material.type == MATERIAL_DIFFUSE) {
        success = diffuseMaterial(hitRecord, ray, resultColor);
      }
      if (hitRecord.material.type == MATERIAL_METAL) {
        success = metalMaterial(hitRecord, ray, resultColor);
      }

      //if some error (mirrored ray goes exactly with the same direction back, i.e. input direction = output direction, so infinite bounces)
      //we break calculations
      if (success == false) {
        depth = 0;
        break;
      }
      depth -= 1;
    } else {
      break;
    }
  }

  //objects are dark, only background has color
  if (depth <= 0)
    return vec3(0.0, 0.0, 0.0);

  float t = 0.5 * (ray.direction.y + 1);
  return resultColor * ((1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0));
}

void main() {
  seed = InitRandomSeed(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
  ivec2 dim = imageSize(resultImage);
  //need to pass via uniform
  float aspect = 800.0 / 592.0;
  float focalLength = 1;

  spheresNumber = 4;
  spheres[0] = Sphere(vec3(0.0, 0.0, -1.0), 0.5, Material(MATERIAL_DIFFUSE, vec3(0.1, 0.5, 0.1), 0.0));
  spheres[1] = Sphere(vec3(0.0, -100.5, -1.0), 100, Material(MATERIAL_DIFFUSE, vec3(0.5, 0.5, 0.5), 0.0));
  spheres[2] = Sphere(vec3(-1.0, 0.0, -1.0), 0.5, Material(MATERIAL_METAL, vec3(0.8, 0.8, 0.8), 0.3));
  spheres[3] = Sphere(vec3(1.0, 0.0, -1.0), 0.5, Material(MATERIAL_METAL, vec3(0.8, 0.6, 0.2), 1.0));
  
  
  //TODO: generate once outside shader
  vec2 aa[AA_SAMPLES];
  int number = 0;
  for (int i = 0; i < sqrt(AA_SAMPLES); i++) {
    for (int j = 0; j < sqrt(AA_SAMPLES); j++) {
      aa[number] = vec2(0.25 * (2 * j + 1), 0.25 * (2 * i + 1));
      number += 1;
    }
  }
  vec3 result = vec3(0.0, 0.0, 0.0);
  for (int i = 0; i < AA_SAMPLES; i++) {
    //range is [0, 1]
    vec2 uv = (gl_GlobalInvocationID.xy + aa[i]) / dim;
    //should be origin of camera
    vec3 rayO = vec3(0.0, 0.0, 0.0);
    //assume surface size as -1 1 but need to take in account aspect ratio
    //assume f is 1
    vec3 rayE = vec3((uv * 2.0 - 1.0) * vec2(aspect, 1.0), -focalLength);
    Ray ray = Ray(rayO, normalize(rayE - rayO));
    result += rayColor(ray);
  }
  result /= AA_SAMPLES;
  imageStore(resultImage, ivec2(gl_GlobalInvocationID.x, dim.y - gl_GlobalInvocationID.y), vec4(result, 1.0));
}